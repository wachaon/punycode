{
    "{49E6F843-EA57-4CCF-92D1-6B22A0F72E7C}": {
        "source": "(function $43$3A$2F$62$69$6E$2F$67$69$74$68$75$62$2F$6D$6F$6E$6F$72$65$70$6F$2F$6E$6F$64$65$5F$6D$6F$64$75$6C$65$73$2F$70$75$6E$79$63$6F$64$65$2F$70$75$6E$79$63$6F$64$65$2E$6A$73() { \"use strict\";\n'use strict';\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar maxInt = 2147483647;\nvar base = 36;\nvar tMin = 1;\nvar tMax = 26;\nvar skew = 38;\nvar damp = 700;\nvar initialBias = 72;\nvar initialN = 128;\nvar delimiter = '-';\nvar regexPunycode = /^xn--/;\nvar regexNonASCII = /[^\\0-\\x7E]/;\nvar regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g;\nvar errors = {\n  'overflow': 'Overflow: input needs wider integers to process',\n  'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n  'invalid-input': 'Invalid input'\n};\nvar baseMinusTMin = base - tMin;\nvar floor = Math.floor;\nvar stringFromCharCode = String.fromCharCode;\n\nfunction error(type) {\n  throw new RangeError(errors[type]);\n}\n\nfunction map(array, fn) {\n  var result = [];\n  var length = array.length;\n\n  while (length--) {\n    result[length] = fn(array[length]);\n  }\n\n  return result;\n}\n\nfunction mapDomain(string, fn) {\n  var parts = string.split('@');\n  var result = '';\n\n  if (parts.length > 1) {\n    result = parts[0] + '@';\n    string = parts[1];\n  }\n\n  string = string.replace(regexSeparators, '\\x2E');\n  var labels = string.split('.');\n  var encoded = map(labels, fn).join('.');\n  return result + encoded;\n}\n\nfunction ucs2decode(string) {\n  var output = [];\n  var counter = 0;\n  var length = string.length;\n\n  while (counter < length) {\n    var value = string.charCodeAt(counter++);\n\n    if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n      var extra = string.charCodeAt(counter++);\n\n      if ((extra & 0xFC00) == 0xDC00) {\n        output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n      } else {\n        output.push(value);\n        counter--;\n      }\n    } else {\n      output.push(value);\n    }\n  }\n\n  return output;\n}\n\nvar ucs2encode = function ucs2encode(array) {\n  return String.fromCodePoint.apply(String, _toConsumableArray(array));\n};\n\nvar basicToDigit = function basicToDigit(codePoint) {\n  if (codePoint - 0x30 < 0x0A) {\n    return codePoint - 0x16;\n  }\n\n  if (codePoint - 0x41 < 0x1A) {\n    return codePoint - 0x41;\n  }\n\n  if (codePoint - 0x61 < 0x1A) {\n    return codePoint - 0x61;\n  }\n\n  return base;\n};\n\nvar digitToBasic = function digitToBasic(digit, flag) {\n  return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n};\n\nvar adapt = function adapt(delta, numPoints, firstTime) {\n  var k = 0;\n  delta = firstTime ? floor(delta / damp) : delta >> 1;\n  delta += floor(delta / numPoints);\n\n  for (; delta > baseMinusTMin * tMax >> 1; k += base) {\n    delta = floor(delta / baseMinusTMin);\n  }\n\n  return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n};\n\nvar decode = function decode(input) {\n  var output = [];\n  var inputLength = input.length;\n  var i = 0;\n  var n = initialN;\n  var bias = initialBias;\n  var basic = input.lastIndexOf(delimiter);\n\n  if (basic < 0) {\n    basic = 0;\n  }\n\n  for (var j = 0; j < basic; ++j) {\n    if (input.charCodeAt(j) >= 0x80) {\n      error('not-basic');\n    }\n\n    output.push(input.charCodeAt(j));\n  }\n\n  for (var index = basic > 0 ? basic + 1 : 0; index < inputLength;) {\n    var oldi = i;\n\n    for (var w = 1, k = base;; k += base) {\n      if (index >= inputLength) {\n        error('invalid-input');\n      }\n\n      var digit = basicToDigit(input.charCodeAt(index++));\n\n      if (digit >= base || digit > floor((maxInt - i) / w)) {\n        error('overflow');\n      }\n\n      i += digit * w;\n      var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\n      if (digit < t) {\n        break;\n      }\n\n      var baseMinusT = base - t;\n\n      if (w > floor(maxInt / baseMinusT)) {\n        error('overflow');\n      }\n\n      w *= baseMinusT;\n    }\n\n    var out = output.length + 1;\n    bias = adapt(i - oldi, out, oldi == 0);\n\n    if (floor(i / out) > maxInt - n) {\n      error('overflow');\n    }\n\n    n += floor(i / out);\n    i %= out;\n    output.splice(i++, 0, n);\n  }\n\n  return String.fromCodePoint.apply(String, output);\n};\n\nvar encode = function encode(input) {\n  var output = [];\n  input = ucs2decode(input);\n  var inputLength = input.length;\n  var n = initialN;\n  var delta = 0;\n  var bias = initialBias;\n\n  var _iterator = _createForOfIteratorHelper(input),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _currentValue2 = _step.value;\n\n      if (_currentValue2 < 0x80) {\n        output.push(stringFromCharCode(_currentValue2));\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  var basicLength = output.length;\n  var handledCPCount = basicLength;\n\n  if (basicLength) {\n    output.push(delimiter);\n  }\n\n  while (handledCPCount < inputLength) {\n    var m = maxInt;\n\n    var _iterator2 = _createForOfIteratorHelper(input),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var currentValue = _step2.value;\n\n        if (currentValue >= n && currentValue < m) {\n          m = currentValue;\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    var handledCPCountPlusOne = handledCPCount + 1;\n\n    if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n      error('overflow');\n    }\n\n    delta += (m - n) * handledCPCountPlusOne;\n    n = m;\n\n    var _iterator3 = _createForOfIteratorHelper(input),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var _currentValue = _step3.value;\n\n        if (_currentValue < n && ++delta > maxInt) {\n          error('overflow');\n        }\n\n        if (_currentValue == n) {\n          var q = delta;\n\n          for (var k = base;; k += base) {\n            var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\n            if (q < t) {\n              break;\n            }\n\n            var qMinusT = q - t;\n            var baseMinusT = base - t;\n            output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n            q = floor(qMinusT / baseMinusT);\n          }\n\n          output.push(stringFromCharCode(digitToBasic(q, 0)));\n          bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n          delta = 0;\n          ++handledCPCount;\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    ++delta;\n    ++n;\n  }\n\n  return output.join('');\n};\n\nvar toUnicode = function toUnicode(input) {\n  return mapDomain(input, function (string) {\n    return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\n  });\n};\n\nvar toASCII = function toASCII(input) {\n  return mapDomain(input, function (string) {\n    return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;\n  });\n};\n\nvar punycode = {\n  'version': '2.1.0',\n  'ucs2': {\n    'decode': ucs2decode,\n    'encode': ucs2encode\n  },\n  'decode': decode,\n  'encode': encode,\n  'toASCII': toASCII,\n  'toUnicode': toUnicode\n};\nmodule.exports = punycode;} )()",
        "mapping": {},
        "path": "{punycode}/punycode.js"
    },
    "{BEC554DF-0404-42EC-BCE5-771CDEC1D9D5}": {
        "source": "{\n  \"_from\": \"punycode@^2.1.1\",\n  \"_id\": \"punycode@2.1.1\",\n  \"_inBundle\": false,\n  \"_integrity\": \"sha512-XRsRjdf+j5ml+y/6GKHPZbrF/8p2Yga0JPtdqTIY2Xe5ohJPD9saDJJLPvp9+NSBprVvevdXZybnj2cv8OEd0A==\",\n  \"_location\": \"/punycode\",\n  \"_phantomChildren\": {},\n  \"_requested\": {\n    \"type\": \"range\",\n    \"registry\": true,\n    \"raw\": \"punycode@^2.1.1\",\n    \"name\": \"punycode\",\n    \"escapedName\": \"punycode\",\n    \"rawSpec\": \"^2.1.1\",\n    \"saveSpec\": null,\n    \"fetchSpec\": \"^2.1.1\"\n  },\n  \"_requiredBy\": [\n    \"/\"\n  ],\n  \"_resolved\": \"https://registry.npmjs.org/punycode/-/punycode-2.1.1.tgz\",\n  \"_shasum\": \"b58b010ac40c22c5657616c8d2c2c02c7bf479ec\",\n  \"_spec\": \"punycode@^2.1.1\",\n  \"_where\": \"C:\\\\bin\\\\github\\\\monorepo\",\n  \"author\": {\n    \"name\": \"Mathias Bynens\",\n    \"url\": \"https://mathiasbynens.be/\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/bestiejs/punycode.js/issues\"\n  },\n  \"bundleDependencies\": false,\n  \"contributors\": [\n    {\n      \"name\": \"Mathias Bynens\",\n      \"url\": \"https://mathiasbynens.be/\"\n    }\n  ],\n  \"deprecated\": false,\n  \"description\": \"A robust Punycode converter that fully complies to RFC 3492 and RFC 5891, and works on nearly all JavaScript platforms.\",\n  \"devDependencies\": {\n    \"codecov\": \"^1.0.1\",\n    \"istanbul\": \"^0.4.1\",\n    \"mocha\": \"^2.5.3\"\n  },\n  \"engines\": {\n    \"node\": \">=6\"\n  },\n  \"files\": [\n    \"LICENSE-MIT.txt\",\n    \"punycode.js\",\n    \"punycode.es6.js\"\n  ],\n  \"homepage\": \"https://mths.be/punycode\",\n  \"jsnext:main\": \"punycode.es6.js\",\n  \"jspm\": {\n    \"map\": {\n      \"./punycode.js\": {\n        \"node\": \"@node/punycode\"\n      }\n    }\n  },\n  \"keywords\": [\n    \"punycode\",\n    \"unicode\",\n    \"idn\",\n    \"idna\",\n    \"dns\",\n    \"url\",\n    \"domain\"\n  ],\n  \"license\": \"MIT\",\n  \"main\": \"punycode.js\",\n  \"module\": \"punycode.es6.js\",\n  \"name\": \"punycode\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/bestiejs/punycode.js.git\"\n  },\n  \"scripts\": {\n    \"prepublish\": \"node scripts/prepublish.js\",\n    \"test\": \"mocha tests\"\n  },\n  \"version\": \"2.1.1\"\n}\n",
        "path": "{punycode}/package.json"
    }
}